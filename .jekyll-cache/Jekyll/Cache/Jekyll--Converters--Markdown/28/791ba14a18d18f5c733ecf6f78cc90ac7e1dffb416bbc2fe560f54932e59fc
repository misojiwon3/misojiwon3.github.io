I"ij<h2 id="symbol">Symbol</h2>

<p>클래스 명, 메소드 명 등 정의하고 이름을 지정할 수 있는 모든 것들이 해당<br />
엔티티 : class, object, trait<br />
멤버 : val, var, def</p>

<h3 id="symbol의-구조">Symbol의 구조</h3>
<p>Symbol은 계층 구조로 구성</p>
<ul>
  <li>메소드의 파라미터는 메소드의 하위 계층</li>
  <li>클래스의 메소드는 클래스의 하위 계층</li>
  <li>패키지의 클래스는 패키지의 하위 계층</li>
  <li>최상위 엔티티와 같이 상위 계층이 없다면 NoSymbol</li>
</ul>

<h4 id="typesymbols">TypeSymbols</h4>
<p>type, class, trait, type parameters 등의 선언을 표현<br />
ClassSymbol : class, trait 등 선언된 모든 정보에 접근 가능</p>

<h4 id="termsymbols">TermSymbols</h4>
<p>val, var, def, object, package 등의 선언을 표현
MethodSymbol : 메소드가 생성자인지 가변길이 파라미터를 지원하는 함수인지 확
ModuleSymbol : 멤버 moduleClass를 통해 객체 정의와 암시 적으로 연결된 클래스를 조회 가능</p>

<h3 id="symbol-변환">Symbol 변환</h3>
<p>일반적인 Symbol을 보다 구체적인 Symbol로 변환할 수 있음
(asClass, asMethod 등)</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.reflect.runtime.universe._</span>
<span class="k">import</span> <span class="nn">scala.reflect.runtime.universe._</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">C</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">test</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)(</span><span class="n">y</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">???</span> <span class="o">}</span>
<span class="n">defined</span> <span class="k">class</span> <span class="nc">C</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">testMember</span> <span class="k">=</span> <span class="n">typeOf</span><span class="o">[</span><span class="kt">C</span><span class="o">[</span><span class="kt">Int</span><span class="o">]].</span><span class="py">member</span><span class="o">(</span><span class="nc">TermName</span><span class="o">(</span><span class="s">"test"</span><span class="o">))</span>
<span class="n">testMember</span><span class="k">:</span> <span class="kt">reflect.runtime.universe.Symbol</span> <span class="o">=</span> <span class="n">method</span> <span class="n">test</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">testMember</span><span class="o">.</span><span class="py">asMethod</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">reflect.runtime.universe.MethodSymbol</span> <span class="o">=</span> <span class="n">method</span> <span class="n">test</span>
</code></pre></div></div>

<h2 id="types">Types</h2>
<p>Symbol의 type에 대한 정보를 나타냄</p>

<h3 id="인스턴스화-types">인스턴스화 Types</h3>
<p>Type을 인스턴스화 하는데에는 세 가지 방법이 존재
	1. typeOf 메소드 사용</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">typeOf</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">reflect.runtime.universe.Type</span> <span class="o">=</span> <span class="nv">scala</span><span class="o">.</span><span class="py">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

<span class="k">#</span> <span class="n">아래와</span> <span class="n">같은</span> <span class="n">메소르를</span> <span class="n">생성하여</span> <span class="n">지정된</span> <span class="n">타입이</span> <span class="n">아닌</span> <span class="n">인스턴스를</span> <span class="n">통해</span> <span class="n">직접</span> <span class="n">type을</span> <span class="n">얻을</span> <span class="n">수</span> <span class="n">있음</span>
<span class="n">scala</span><span class="o">&gt;</span>  <span class="k">def</span> <span class="nf">getType</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">TypeTag</span><span class="o">](</span><span class="n">obj</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="n">typeOf</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="n">getType</span><span class="k">:</span> <span class="err">[</span><span class="kt">T</span><span class="err">]</span><span class="o">(</span><span class="kt">obj:</span> <span class="kt">T</span><span class="o">)(</span><span class="kt">implicit</span> <span class="kt">evidence$1:</span> <span class="kt">reflect.runtime.universe.TypeTag</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="nv">reflect</span><span class="o">.</span><span class="py">runtime</span><span class="o">.</span><span class="py">universe</span><span class="o">.</span><span class="py">Type</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">getType</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">reflect.runtime.universe.Type</span> <span class="o">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Animal</span><span class="o">;</span> <span class="k">class</span> <span class="nc">Cat</span> <span class="k">extends</span> <span class="nc">Animal</span>
<span class="n">defined</span> <span class="k">class</span> <span class="nc">Animal</span>
<span class="n">defined</span> <span class="k">class</span> <span class="nc">Cat</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Animal</span>
<span class="n">a</span><span class="k">:</span> <span class="kt">Animal</span> <span class="o">=</span> <span class="nc">Animal</span><span class="k">@</span><span class="mf">325236f</span><span class="mi">5</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">getType</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">reflect.runtime.universe.Type</span> <span class="o">=</span> <span class="nc">Animal</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">c</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cat</span>
<span class="n">c</span><span class="k">:</span> <span class="kt">Cat</span> <span class="o">=</span> <span class="nc">Cat</span><span class="k">@</span><span class="mi">313</span><span class="n">a3af8</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">getType</span><span class="o">(</span><span class="n">c</span><span class="o">)</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">reflect.runtime.universe.Type</span> <span class="o">=</span> <span class="nc">Cat</span>
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2. 기본 타입 사용 ```scala scala&gt; import scala.reflect.runtime.universe import scala.reflect.runtime.universe
</code></pre></div></div>

<p>scala&gt; val intTpe = universe.definitions.IntTpe
intTpe: scala.reflect.runtime.universe.Type = Int</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
## Tree
Scala Refletion에서 tree를 생성하거나 사용하는 API는 다음 세 가지가 있다
	1. tree를 사용하여 arguments를 나타내는 Scala Annotations는 `Annotation.scalaArgs`에 표현
	2. expression로 AST를 리턴하는 `reify`라는 메소드 사용
	3. 매크로를 사용한 Compile-time reflection 및 툴박스를 사용한 runtime compile은 트리를 프로그램 표현 매체로 사용
 
트리의 종류
	1. TermTree
	2. TypTree
	3. SymTree

### Tree 검사
show 메소드를 사용하여 tree에 의해 표현되는 scala 슈도코드 출력
```scala
scala&gt; import scala.reflect.runtime.universe._
import scala.reflect.runtime.universe._

scala&gt; val tree = Apply(Select(Ident(TermName("x")), TermName("$plus")), List(Literal(Constant(2))))
tree: reflect.runtime.universe.Apply = x.$plus(2)

scala&gt; show(tree)
res50: String = x.$plus(2)

scala&gt; tree.toString
res51: String = x.$plus(2)
</code></pre></div></div>

<p>showRaw 메소드를 사용하여 raw internal tree를 볼 수 있음</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">expr</span> <span class="k">=</span> <span class="n">reify</span> <span class="o">{</span> <span class="k">class</span> <span class="nc">Flower</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">name</span> <span class="k">=</span> <span class="s">"Rose"</span> <span class="o">}</span> <span class="o">}</span>
<span class="n">expr</span><span class="k">:</span> <span class="kt">reflect.runtime.universe.Expr</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">Expr</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]({</span>
  <span class="k">class</span> <span class="nc">Flower</span> <span class="k">extends</span> <span class="nc">AnyRef</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">&lt;</span><span class="n">init</span><span class="o">&gt;()</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">super</span><span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;();</span>
      <span class="o">()</span>
    <span class="o">};</span>
    <span class="k">def</span> <span class="nf">name</span> <span class="k">=</span> <span class="s">"Rose"</span>
  <span class="o">};</span>
  <span class="o">()</span>
<span class="o">})</span>
</code></pre></div></div>
<p>여기서 <code class="language-plaintext highlighter-rouge">reify</code>는 Scala expression을 가져와서 Scala Expr를 반환하며 Tree와 TypeTag를 래핑</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">tree</span> <span class="k">=</span> <span class="nv">expr</span><span class="o">.</span><span class="py">tree</span>
<span class="n">tree</span><span class="k">:</span> <span class="kt">reflect.runtime.universe.Tree</span> <span class="o">=</span>
<span class="o">{</span>
  <span class="k">class</span> <span class="nc">Flower</span> <span class="k">extends</span> <span class="nc">AnyRef</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">&lt;</span><span class="n">init</span><span class="o">&gt;()</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">super</span><span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;();</span>
      <span class="o">()</span>
    <span class="o">};</span>
    <span class="k">def</span> <span class="nf">name</span> <span class="k">=</span> <span class="s">"Rose"</span>
  <span class="o">};</span>
  <span class="o">()</span>
<span class="o">}</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">showRaw</span><span class="o">(</span><span class="n">tree</span><span class="o">)</span>
<span class="n">res61</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Block</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">ClassDef</span><span class="o">(</span><span class="nc">Modifiers</span><span class="o">(),</span> <span class="nc">TypeName</span><span class="o">(</span><span class="s">"Flower"</span><span class="o">),</span> <span class="nc">List</span><span class="o">(),</span> <span class="nc">Template</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Ident</span><span class="o">(</span><span class="nc">TypeName</span><span class="o">(</span><span class="s">"AnyRef"</span><span class="o">))),</span> <span class="n">noSelfType</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="nc">DefDef</span><span class="o">(</span><span class="nc">Modifiers</span><span class="o">(),</span> <span class="nv">termNames</span><span class="o">.</span><span class="py">CONSTRUCTOR</span><span class="o">,</span> <span class="nc">List</span><span class="o">(),</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">()),</span> <span class="nc">TypeTree</span><span class="o">(),</span> <span class="nc">Block</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Apply</span><span class="o">(</span><span class="nc">Select</span><span class="o">(</span><span class="nc">Super</span><span class="o">(</span><span class="nc">This</span><span class="o">(</span><span class="nv">typeNames</span><span class="o">.</span><span class="py">EMPTY</span><span class="o">),</span> <span class="nv">typeNames</span><span class="o">.</span><span class="py">EMPTY</span><span class="o">),</span> <span class="nv">termNames</span><span class="o">.</span><span class="py">CONSTRUCTOR</span><span class="o">),</span> <span class="nc">List</span><span class="o">())),</span> <span class="nc">Literal</span><span class="o">(</span><span class="nc">Constant</span><span class="o">(())))),</span> <span class="nc">DefDef</span><span class="o">(</span><span class="nc">Modifiers</span><span class="o">(),</span> <span class="nc">TermName</span><span class="o">(</span><span class="s">"name"</span><span class="o">),</span> <span class="nc">List</span><span class="o">(),</span> <span class="nc">List</span><span class="o">(),</span> <span class="nc">TypeTree</span><span class="o">(),</span> <span class="nc">Literal</span><span class="o">(</span><span class="nc">Constant</span><span class="o">(</span><span class="s">"Rose"</span><span class="o">))))))),</span> <span class="nc">Literal</span><span class="o">(</span><span class="nc">Constant</span><span class="o">(())))</span>
</code></pre></div></div>

<h3 id="tree-순회">Tree 순회</h3>
<p>Tree으로부터 정보를 추출하는 것은 트리 순회를 통해 가능하며 두 가지 방법이 존재한다.</p>

<h4 id="패턴-매칭을-통한-순회">패턴 매칭을 통한 순회</h4>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.reflect.runtime.universe._</span>
<span class="k">import</span> <span class="nn">scala.reflect.runtime.universe._</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">tree</span> <span class="k">=</span> <span class="nc">Apply</span><span class="o">(</span><span class="nc">Select</span><span class="o">(</span><span class="nc">Ident</span><span class="o">(</span><span class="nc">TermName</span><span class="o">(</span><span class="s">"x"</span><span class="o">)),</span> <span class="nc">TermName</span><span class="o">(</span><span class="s">"$plus"</span><span class="o">)),</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Literal</span><span class="o">(</span><span class="nc">Constant</span><span class="o">(</span><span class="mi">2</span><span class="o">))))</span>
<span class="n">tree</span><span class="k">:</span> <span class="kt">reflect.runtime.universe.Apply</span> <span class="o">=</span> <span class="nv">x</span><span class="o">.</span><span class="py">$plus</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">val</span> <span class="o">(</span><span class="n">fun</span><span class="o">,</span> <span class="n">arg</span><span class="o">)</span> <span class="k">=</span> <span class="n">tree</span> <span class="k">match</span> <span class="o">{</span>
     <span class="o">|</span>   <span class="k">case</span> <span class="nc">Apply</span><span class="o">(</span><span class="n">fn</span><span class="o">,</span> <span class="n">a</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">fn</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
     <span class="o">|</span> <span class="o">}</span>
<span class="n">fun</span><span class="k">:</span> <span class="kt">reflect.runtime.universe.Tree</span> <span class="o">=</span> <span class="nv">x</span><span class="o">.</span><span class="py">$plus</span>
<span class="n">arg</span><span class="k">:</span> <span class="kt">reflect.runtime.universe.Tree</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">Apply</span><span class="o">(</span><span class="n">fun</span><span class="o">,</span> <span class="n">arg</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=</span> <span class="n">tree</span>
<span class="n">fun</span><span class="k">:</span> <span class="kt">reflect.runtime.universe.Tree</span> <span class="o">=</span> <span class="nv">x</span><span class="o">.</span><span class="py">$plus</span>
<span class="n">arg</span><span class="k">:</span> <span class="kt">reflect.runtime.universe.Tree</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div></div>

<p>하지만 트리는 일반적으로 더 복잡할 수 있다.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">tree</span> <span class="k">=</span> <span class="nc">Apply</span><span class="o">(</span><span class="nc">Select</span><span class="o">(</span><span class="nc">Apply</span><span class="o">(</span><span class="nc">Select</span><span class="o">(</span><span class="nc">Ident</span><span class="o">(</span><span class="nc">TermName</span><span class="o">(</span><span class="s">"x"</span><span class="o">)),</span> <span class="nc">TermName</span><span class="o">(</span><span class="s">"$plus"</span><span class="o">)),</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Literal</span><span class="o">(</span><span class="nc">Constant</span><span class="o">(</span><span class="mi">2</span><span class="o">)))),</span> <span class="nc">TermName</span><span class="o">(</span><span class="s">"$plus"</span><span class="o">)),</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Literal</span><span class="o">(</span><span class="nc">Constant</span><span class="o">(</span><span class="mi">3</span><span class="o">))))</span>
<span class="n">tree</span><span class="k">:</span> <span class="kt">reflect.runtime.universe.Apply</span> <span class="o">=</span> <span class="nv">x</span><span class="o">.</span><span class="py">$plus</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="py">$plus</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">Apply</span><span class="o">(</span><span class="n">fun</span><span class="o">,</span> <span class="n">arg</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=</span> <span class="n">tree</span>
<span class="n">fun</span><span class="k">:</span> <span class="kt">reflect.runtime.universe.Tree</span> <span class="o">=</span> <span class="nv">x</span><span class="o">.</span><span class="py">$plus</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="py">$plus</span>
<span class="n">arg</span><span class="k">:</span> <span class="kt">reflect.runtime.universe.Tree</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div></div>
<p>중첩된 Tree를 순회하는 데에는 Traverser를 이용하는 것이 더 효율적일 수 있다.</p>

<h4 id="traverser를-통한-순회">Traverser를 통한 순회</h4>
<p>복잡한 트리의 경우 트리의 깊이가 깊어지는데 이러한 트리를 순회하기 위해 패턴 매칭을 사용해야 한다면 모든 유형의 노드를 개별 처리해야 한다. 따라서 이러한 경우에는 Traverser 클래스를 사용한다.</p>

<p>Traverser를 사용하려면 Traverser의 traverse 메소드를 override 한다. 이렇게 하면 원하는 케이스만 추출해 낼 수 있습니다.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">tree</span> <span class="k">=</span> <span class="nc">Apply</span><span class="o">(</span><span class="nc">Select</span><span class="o">(</span><span class="nc">Apply</span><span class="o">(</span><span class="nc">Select</span><span class="o">(</span><span class="nc">Ident</span><span class="o">(</span><span class="nc">TermName</span><span class="o">(</span><span class="s">"x"</span><span class="o">)),</span> <span class="nc">TermName</span><span class="o">(</span><span class="s">"$plus"</span><span class="o">)),</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Literal</span><span class="o">(</span><span class="nc">Constant</span><span class="o">(</span><span class="mi">2</span><span class="o">)))),</span> <span class="nc">TermName</span><span class="o">(</span><span class="s">"$plus"</span><span class="o">)),</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Literal</span><span class="o">(</span><span class="nc">Constant</span><span class="o">(</span><span class="mi">3</span><span class="o">))))</span>
<span class="n">tree</span><span class="k">:</span> <span class="kt">scala.reflect.runtime.universe.Apply</span> <span class="o">=</span> <span class="nv">x</span><span class="o">.</span><span class="py">$plus</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="py">$plus</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">object</span> <span class="nc">traverser</span> <span class="k">extends</span> <span class="nc">Traverser</span> <span class="o">{</span>
     <span class="o">|</span>   <span class="k">var</span> <span class="n">applies</span> <span class="k">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Apply</span><span class="o">]()</span>
     <span class="o">|</span>   <span class="k">override</span> <span class="k">def</span> <span class="nf">traverse</span><span class="o">(</span><span class="n">tree</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">tree</span> <span class="k">match</span> <span class="o">{</span>
     <span class="o">|</span>     <span class="k">case</span> <span class="n">app</span> <span class="k">@</span> <span class="nc">Apply</span><span class="o">(</span><span class="n">fun</span><span class="o">,</span> <span class="n">args</span><span class="o">)</span> <span class="k">=&gt;</span>
     <span class="o">|</span>       <span class="n">applies</span> <span class="k">=</span> <span class="n">app</span> <span class="o">::</span> <span class="n">applies</span>
     <span class="o">|</span>       <span class="nv">super</span><span class="o">.</span><span class="py">traverse</span><span class="o">(</span><span class="n">fun</span><span class="o">)</span>
     <span class="o">|</span>       <span class="nv">super</span><span class="o">.</span><span class="py">traverseTrees</span><span class="o">(</span><span class="n">args</span><span class="o">)</span>
     <span class="o">|</span>     <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nv">super</span><span class="o">.</span><span class="py">traverse</span><span class="o">(</span><span class="n">tree</span><span class="o">)</span>
     <span class="o">|</span>   <span class="o">}</span>
     <span class="o">|</span> <span class="o">}</span>
<span class="n">defined</span> <span class="n">module</span> <span class="n">traverser</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">traverser</span><span class="o">.</span><span class="py">traverse</span><span class="o">(</span><span class="n">tree</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">traverser</span><span class="o">.</span><span class="py">applies</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">reflect.runtime.universe.Apply</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nv">x</span><span class="o">.</span><span class="py">$plus</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span> <span class="nv">x</span><span class="o">.</span><span class="py">$plus</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="py">$plus</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>
</code></pre></div></div>
:ET